<html>
<head>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/minireset.css/0.0.2/minireset.css">
<link rel="stylesheet" type="text/css" href="index.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>
<script src="nameList.js"></script>
<script src="utilities.js"></script>
<script src="data.js"></script>
<script src="sentence.js"></script>
<script src="finder.js"></script>
<qscript src="levels.js"></script>
<script>

let humanNameList = Array.shuffle(getNameList());


let MessageManager = (new class {
	constructor() {
		this.recipientList = [];
	}
	addRecipient( observer, canPerceiveFn, receiveFn ) {
		this.recipientList.push( { observer: observer, canPerceiveFn: canPerceiveFn, receiveFn: receiveFn, history: [] });
	}
	tell() {
		let sentence = ( arguments[0] instanceof Sentence ) ? arguments[0] : new Sentence(...arguments);
		if( !sentence.subject ) {
			debugger;
		}
		this.recipientList.map( recipient => {
			let cp = recipient.canPerceiveFn(recipient.observer,sentence.subject.x,sentence.subject.y);
			if( sentence.object ) {
				cp = cp || recipient.canPerceiveFn(recipient.observer,sentence.object.x,sentence.object.y);
			}

			if( cp || recipient.observer.observeDistantEvents ) {
				let message = (cp?'':'FAR: ')+sentence.refine(recipient.observer);
				recipient.history.unshift(message);
				recipient.receiveFn(message,recipient.history);
			}
		});
	}
}());

function tell() {
	MessageManager.tell(...arguments);
}

function bonk(entity,target) {
	tell( mSubject, entity, ' ', mVerb, 'run', ' into ', mObject, target, '.' );
}


// DEED

class Deed {
	// Set duration = true for perpetual
	constructor(cause,entity,duration,stat,op,value,onTick,onEnd,data) {
		if( entity[stat] === undefined ) {
			debugger;
		}this.cause = cause;
		this.entity = entity;
		this.stat = stat;
		this.op = op;
		this.value = value;
		this.duration = duration;
		this.onTick = onTick;
		this.onEnd = onEnd;
		this.data = data;
		this.timeLeft = duration;
		this.killMe = false;
	}
	expired() {
		return this.killMe || (this.timeLeft!==true && this.timeLeft <= 0);
	}
	applyEffect() {
		if( this.op == 'set' ) {
			this.entity[this.stat] = this.value;
		}
		if( this.op == 'add' ) {
			if( typeof this.entity[this.stat] === 'string' ) {
				this.entity[this.stat] = String.arAdd(this.entity[this.stat],this.value);
			}
			else {
				this.entity[this.stat] += this.value;
			}
		}
		if( this.op == 'sub' ) {
			if( typeof this.entity[this.stat] === 'string' ) {
				this.entity[this.stat] = String.arSub(this.entity[this.stat],this.value);
			}
			else {
				this.entity[this.stat] -= this.value;
			}
		}
	}
	end() {
		if( this.killMe ) {
			return false;
		}
		if( this.onEnd ) {
			this.onEnd(this.entity,this.data);
		}
		this.killMe = true;
		return true;
	}
	tick(dt) {
		if( this.killMe || !this.doTick ) {
			return;
		}
		if( this.timeLeft !== true ) {
			this.timeLeft -= dt;
		}
		if( this.expired() ) {
			this.end();
		}
		else
		if( this.onTick ) {
			this.onTick(this.entity,dt,this.data);
		}
	}
}

let DeedManager = (new class {
	constructor() {
		this.handler = {};
		this.deedList = [];
	}
	// If an item was involved, then the cause should be the item, and other functions must find the owner.
	add(cause,entity,duration,stat,op,value,onTick,onEnd,data) {
		let handlerFn = this.handler[stat+'_'+op];
		if( handlerFn ) {
			handlerFn(cause,entity,value);
		}
		else {
			this.deedList.push( new Deed(cause,entity,duration,stat,op,value,onTick,onEnd,data) );
		}
	}
	addHandler(stat,op,handlerFn) {
		this.handler[stat+'_'+op] = handlerFn;
	}
	calcStat(entity,stat) {
		let oldValue = entity[stat];
		if( entity.type[stat] === undefined ) {
			debugger;
		}
		entity[stat] = entity.type[stat];
		for( let deed of this.deedList ) {
			if( !deed.killMe && deed.entity.id == entity.id && deed.stat == stat ) {
				deed.applyEffect();
			}
		}
		deedTell(entity,stat,oldValue,entity[stat]);
	}
	calc(entity) {
		let statList = {};
		// WEIRD!! If we just ended a deed, we must STILL calc the value, at least once, so that we can
		// emit notice that it happened!
		this.deedList.map(
			deed => { statList[deed.stat] = true; }
		);
		Object.entries(statList).forEach(
			([stat,dummy]) => { this.calcStat(entity,stat); }
		);
	}
	force(entity,stat,value) {
		this.end(entity,stat);
		this.add(entity,true,stat,'set',value);
		this.calcStat(entity,stat);
	}
	end(entity,stat,value) {
		let count = 0;
		for( let deed of this.deedList ) {
			if( !deed.killMe && deed.entity.id == entity.id && deed.stat == stat && (value===undefined || deed.value==value)) {
				if( deed.end() ) {
					count++;
				}
			}
		}
		return count;
	}
	cleanup() {
		Array.filterInPlace(this.deedList, deed => !deed.killMe );
	}
	tick(entity,dt) {
		// This makes sure that any deeds added while ticking do NOT actually tick this round.
		this.deedList.map( deed => deed.doTick=true );
		for( let deed of this.deedList ) {
			if( deed.entity.id == entity.id ) {
				deed.tick(dt);
			}
		}
	}
}());

let deedAdd = function() {
	return DeedManager.add(...arguments);
}

let deedTell = function(entity,stat,oldValue,newValue ) {
	if( typeof oldValue == 'string' ) {
		// we have to do this before comparing, below, because we do NOT keep the elements sorted.
		let ov = oldValue;
		let nv = newValue;
		oldValue = String.arExtra(ov,nv);
		newValue = String.arExtra(nv,ov);
	}
	if( oldValue == newValue ) {
		return;
	}
	let teller = {
		invisible: function() {
			return [mSubject,entity,' suddenly ',mVerb,newValue?'wink':'appear',newValue?' out of sight':' from thin air','!'];
		},
		speed: function() {
			return [mSubject,entity,' ',mVerb,(newValue<oldValue?'slow':'speed'),' ',(newValue<oldValue?'down':'up'),'.'];
		},
		regenerate: function() {
			return [mSubject|mPossessive,entity,' body ',newValue==0 ? 'stops regenerating.' : (newValue<oldValue ? 'regenerates a bit less.' : 'begins to knit itself back together.')];
		},
		immune: function() {
			return [mSubject|mPossessive,entity,' ',mVerb,'is',' ',!oldValue ? 'now immune to '+newValue : 'no longer immune to '+oldValue,'s.'];
		},
		resist: function() {
			return [mSubject|mPossessive,entity,' ',mVerb,'is',' ',!oldValue ? 'now resistant to '+newValue+'s.' : 'no longer resistant to '+oldValue+'s.'];
		},
		blind: function() {
			return [mSubject,entity,' ',mSubject|mVerb,newValue?'lose':'regain',' ',mSubject|mPronoun|mPossessive,entity,' sight!'];
		},
		travelMode: function() {
			return [mSubject,entity,' ',mSubject|mVerb,'begin',' to ',newValue,'.'];
		},
		attitude: function() {
			return [mSubject,entity,' ',mSubject|mVerb,'become',' ',newValue,'.'];
		},
		_generic_: function() {
			return [mSubject,entity,' ',stat,' ',mVerb,'is',' less enchanted.'];
		}
	}

	let content = (teller[stat] || teller._generic_)();
	tell(...content);
}

DeedManager.addHandler('health','add',function(cause,entity,value) { entity.takeHealing(cause,value,cause.effect.healingType);});
DeedManager.addHandler('health','sub',function(cause,entity,value) { entity.takeDamage(cause,value,cause.effect.damageType,cause.effect.onDamage);});

function adhoc(tileType,x,y) {
	return Object.assign({},tileType,{x:x,y:y});
}

//
// ENTITY (monsters, players etc)
//
class Entity {
	constructor(map,entityList,monsterType,position) {
		let inits =    { inventory: [], actionCount: 0, command: Command.NONE, commandLast: Command.NONE, history: [], historyPending: [], tileTypeLast: TileTypeList.floor };
		let values   = { id: humanNameList.pop(), health: monsterType.healthMax, x:position.x, y:position.y, map: map, entityList:entityList };
		if( monsterType.pronoun == '*' ) {
			values.pronoun = Math.chance(70) ? 'he' : 'she';
		}
		if( monsterType.name.indexOf('/')>0 ) {
			values.name = monsterType.name.split('/')[values.pronoun=='she' ? 1 : 0];
		}
		Object.assign( this, monsterType, inits, values );
	}

	record(s,pending) {
		if( pending ) {
			this.historyPending.push(s);
			return;
		}
		this.history.unshift( this.name+' '+s+' '+this.historyPending.join(', ') );
		this.historyPending.length = 0;
		if( this.watch ) {
			console.log(this.history[0]);
		}
	}

	entityFinder(entityList = this.entityList) {
		return new EntityFinder(this,entityList);
	}

	die() {
		if( this.isVictorious ) {
			return;
		}
		if( this.removed ) {
			debugger;
		}
		tell(mSubject,this,' ',mVerb,'die','!');
		this.removed = true;
	}

	isDead() {
		return this.removed || this.isVictorious || this.health <= 0;
	}
	isAlive() {
		return !this.isDead();
	}

	dirToPredictable(_x,_y) {
		let dx = ( isEntity(_x) ? _x.x : _x ) - this.x;
		let dy = ( isEntity(_x) ? _x.y : _y ) - this.y;
		return deltasToDirPredictable(dx,dy);
	}
	dirToNatural(_x,_y) {
		let dx = ( isEntity(_x) ? _x.x : _x ) - this.x;
		let dy = ( isEntity(_x) ? _x.y : _y ) - this.y;
		return deltasToDirNatural(dx,dy);
	}

	isMyEnemy(entity) {
		if( this.attitude == Attitude.ENRAGED ) {
			return true;
		}
		return entity.team != this.team && entity.team != Team.NEUTRAL;
	}
	isMyFriend(entity) {
		if( this.attitude == Attitude.ENRAGED ) {
			return false;
		}
		return entity.team == this.team && entity.team != Team.NEUTRAL;
	}
	isMyNeutral(entity) {
		if( this.attitude == Attitude.ENRAGED ) {
			return false;
		}
		return this.team == Team.NEUTRAL || entity.team == Team.NEUTRAL;
	}

	calcVis() {
		this.vis = calcVis(this.map,this.x,this.y,this.sightDistance,this.blind,this.vis);
		return this.vis;
	}

	canPerceive(_x,_y) {
		if( !this.vis ) {
			return true;
		}
		if( isEntity(_x) && (this.blind || (_x.invisible && !this.seeInvisible)) && _x.id!==this.id /*you can always perceive yourself*/) {
			return false;
		}
		let x = isEntity(_x) ? _x.x : _x;
		let y = isEntity(_x) ? _x.y : _y;
		if( x===undefined || y===undefined ) {
			debugger;
		}
		if( typeof this.vis[y]==='undefined' || typeof this.vis[y][x]==='undefined' ) {
			return false;
		}
		return this.vis[y][x];
	}

	itemRemove(item) {
		if( !this.inventory.includes(item) ) {
			debugger;
		}
		Array.filterInPlace(this.inventory, i => i.id!=item.id );
	}
	itemTake(item) {
		if( this.inventory.includes(item) ) {
			debugger;
		}
		this.inventory.push(item);
	}

	enemyAtPos(x,y) {
		return this.entityFinder().at(x,y).isMyEnemy();
	}

	at(x,y) {
		let f = this.entityFinder().at(x,y).isAlive();
		return f.first || this.map.tileTypeGet(x,y);
	}

	atDir(x,y,dir) {
		let f = this.entityFinder().atDir(x,y,dir).isAlive();
		return f.first || this.map.tileTypeGetDir(x,y,dir);
	}

	mayEnter(x,y,avoidProblem) {
		let entityType = this.at(x,y);
		let mayTravel = 'may'+String.capitalize(this.travelMode || "walk");
		if( !entityType[mayTravel] ) {
			return false;
		}
		if( avoidProblem && entityType.isProblem && entityType.isProblem(this,entityType) ) {
			return false;
		}
		return true;
	}

	mayGo(dir,avoidProblem) {
		return this.mayEnter(this.x+DirectionAdd[dir].x,this.y+DirectionAdd[dir].y,avoidProblem);
	}

	avoidProblem() {
		// WARNING! This does NOT consider whether the creature is immune to the damage,
		// nor does it understand that their movement mode might be immune.
		return( this.attitude!=Attitude.ENRAGED && this.attitude!=Attitude.CONFUSED && this.attitude!=Attitude.PANICKED);
	}

	thinkWander(walkAnywhere=false) {
		this.record('wander'+(walkAnywhere ? ' anywhere' : ''), true);

		const RandCommand = [Command.N, Command.NE, Command.E, Command.SE, Command.S, Command.SW, Command.W, Command.NW];
		let reps = 4;
		let command;
		do {
			command = RandCommand[Math.randInt(0,RandCommand.length)];
			let dir = commandToDirection(command);
			if( dir !== false ) {
				if( walkAnywhere || this.mayGo(dir,this.avoidProblem()) ) {
					return command;
				}
			}
		} while( --reps );
		return Command.WAIT;
	}

	thinkApproach(target) {
		// Can I walk towards them?
		let dir = this.dirToNatural(target);
		// Aggressive creatures will completely avoid problems if 1/3 health, otherwide they
		// avoid problems most of the time, but eventually will give in and take the risk.
		let avoidProblem = (
			this.attitude == Attitude.HESITANT ||
			this.attitude == Attitude.FEARFUL ||
			(this.attitude == Attitude.AGGRESSIVE && (this.health<this.healthMax/3 || Math.chance(85)) )
		);
		this.record( (avoidProblem ? '' : 'not ')+' avoiding problem', true );

		if( this.mayGo(dir,avoidProblem) ) {
			this.record('approach '+target.name,true);
			return directionToCommand(dir);
		}
		return false;
	}

	think() {
		if( this.isDead() ) {
			return;
		}

		let useAiTemporarily = false;
		if( this.brain == Brain.USER ) {
			// Placeholder, since the onPlayerKey already sets the command for us
			if( this.attitude == Attitude.CONFUSED || this.attitude == Attitude.ENRAGED || this.Attitude == Attitude.PANICKED ) {
				useAiTemporarily = true;
			}
		}

		if( this.brain == Brain.AI || useAiTemporarily ) {
			this.command = (function() {

				if( this.attitude == Attitude.CONFUSED ) {
					return Math.chance(30) ? Command.WAIT : this.thinkWander(true);
				}

				if( this.attitude == Attitude.WANDER ) {
					let dirLast = commandToDirection(this.commandLast);
					if( Math.chance(90) && dirLast !== false && this.mayGo(dirLast,this.avoidProblem()) ) {
						this.record('keep walking',true);
						return this.commandLast;
					}
					return Math.chance(30) ? Command.WAIT : this.thinkWander();
				}

				// Note that attitude enraged makes isMyEnemy() return true for all creatures.
				let enemyList = this.entityFinder().isMyEnemy().canPerceive().byDistance();

				// If no enemy to attack or fles, then just wander around 
				if( !enemyList.count ) {
					this.record('no enemy',true);
					let friendList = this.entityFinder().isMyFriend().farFromMe(2).byDistance();
					if( this.packAnimal && friendList.count ) {
						this.record('back to a friend',true);
						let c = this.thinkApproach(friendList.first);
						if( c !== false ) {
							return c;
						}
					}
					return this.thinkWander();
				}

				// Flee if I am fearful or sometimes if hesitant
				let flee = ( this.attitude == Attitude.FEARFUL || this.attitude == Attitude.PANICKED || (this.attitude == Attitude.HESITANT && Math.chance(40)));
				if( flee ) {
					let panic = (this.attitude == Attitude.PANICKED);
					let dirAway = this.dirToNatural(enemyList.first);
					dirAway = (dirAway + 4 + Math.randInt(0,3)-1) % DirectionCount;
					if( panic || this.mayGo(dirAway,this.avoidProblem()) ) {
						this.record( (panic ? 'panicked flee' : 'fled')+' from '+enemyList.first.name, true );
						return directionToCommand(dirAway);
					}
					this.record('cannot flee',true);
				}

				// Attack if I am within reach, and aggressive or sometimes if hesitant
				let adjacent = this.entityFinder(enemyList.all).nearMe(this.reach);
				if( adjacent.count ) {
					let attack = ( this.attitude == Attitude.AGGRESSIVE || this.attitude == Attitude.ENRAGED || (this.attitude == Attitude.HESITANT && Math.chance(50)) );
					if( attack ) {
						this.record('attack '+adjacent.first.name,true);
						return directionToCommand(this.dirToPredictable(adjacent.first));
					}
				}

				let c = this.thinkApproach(enemyList.first);
				if( c !== false ) {
					return c;
				}
				return Math.random() < 0.50 ? Command.WAIT : this.thinkWander();

			}).apply(this);			

			this.record( this.attitude+" cmd: "+this.command );
		}
	}

	rollDamage(damageString) {
		return rollDice(damageString);
	}

	isImmune(damageType) {
		return String.arIncludes(this.immune,damageType);
	}
	isResistant(damageType) {
		return String.arIncludes(this.resist,damageType);
	}

	takeHealing(healer,amount,healingType) {
		if( healer.isItemType ) {
			healer = healer.cause || healer.owner;
		}
		amount = Math.min( amount, this.healthMax-this.health );
		let quiet = false;
		this.health += amount;
		if( this.onHeal ) {
			quiet = this.onHeal(healer,this,amount,healingType);
		}
		if( !quiet ) {
			let result = (amount ? [' healed by ',mObject,healer,' for '+amount+' health.'] : [' already at full health.']);
			tell(mSubject,this,' ',mVerb,'is',...result);
		}
	}

	takeDamage(attacker,amount,damageType,onDamage) {
		if( attacker.isItemType ) {
			attacker = attacker.cause || attacker.owner;
		}
		if( this.isImmune(damageType) ) {
			amount = 0;
		}
		else
		if( this.isResistant(damageType) ) {
			amount = amount / 2;
		}
		if( attacker && attacker.invisible ) { //&& !this.type.invisible ) {
			DeedManager.force(attacker,"invisible",false);
		}

		this.health -= amount;
		let quiet = false;
		if( this.onDamage ) {
			quiet = this.onDamage(attacker,this,amount,damageType);
		}
		if( !quiet ) {
			tell(mSubject,attacker,' ',mVerb,damageType,' ',mObject,this,amount<=0 ? ' with no effect!' : ' for '+amount+' damage!' );
		}
	}

	doDamage(other,amount,damageType,onDamage) {
		return other.takeDamage(this,amount,damageType,onDamage);
	}

	attack(other,isRanged,onDamage) {
		if( (this.blind && !this.type().blind) || (other.invisible && !this.seeInvisible) ) {
			if( Math.chance(50) ) {
				tell(mSubject,this,' ',mVerb,'attack',' ',mObject,other,' but in the wrong direction!');
				return;
			}
		}
		let damage = this.rollDamage(this.damage);
		let damageType = this.damageType || DamageType.STAB;
		let result = this.doDamage( other, damage, damageType, onDamage );
		if( !isRanged && other.onTouch ) {
			other.onTouch(this,other);
		}
		return result;
	}

	setPosition(x,y) {
		if( this.x == x && this.y == y ) {
			return;
		}
		this.tileTypeLast = this.map.tileTypeGet(this.x,this.y);
		this.x = x;
		this.y = y;
	}

	moveDir(dir) {
		let x = this.x + DirectionAdd[dir].x;
		let y = this.y + DirectionAdd[dir].y;
		return this.moveTo(x,y);
	}
	moveTo(x,y) {
		if( this.map.inBounds(x,y) ) {
			let entityList = this.entityFinder().at(x,y);

			// Attack enemies or neutrals
			if( entityList.count && (this.isMyEnemy(entityList.first) || this.isMyNeutral(entityList.first)) ) {
				this.attack(entityList.first);
				return;
			}
			else
			// Switch with friends, else bonk!
			if( entityList.count && this.isMyFriend(entityList.first) ) {
				if( this.brain == 'user' ) {
					// swap places by revrsing the direction user moved with the drection friend moved.
					//but for now simply deny.
				}
				(entityList.first.onTouch || bonk)(this,entityList.first);
				return;
			}

			let xOld = this.x;
			let yOld = this.y;
			let tileTypeHere = this.map.tileTypeGet(xOld,yOld);
			let tileType = this.map.tileTypeGet(x,y);

			if( tileTypeHere.onDepart ) {
				if( tileTypeHere.onDepart(this,adhoc(tileTypeHere,xOld,yOld)) === false ) {
					return;
				}
			}
			// Are we leaving this type of tile?
			if( tileType.name != tileTypeHere.name && tileTypeHere.onDepartType ) {
				if( tileTypeHere.onDepartType(this,adhoc(tileTypeHere,xOld,yOld),adhoc(tileType,x,y)) === false ) {
					return;
				}
			}

			// Now only tiles and items are left.
			if( !this.mayEnter(x,y) ) {
				(tileType.onTouch || bonk)(this,adhoc(tileType,x,y));
				return;
			}

			// Are we entering a new tile type?
			if( tileType.name != tileTypeHere.name && tileType.onEnterType ) {
				if( tileType.onEnterType(this,adhoc(tileType,x,y),tileTypeHere,xOld,yOld) === false ) {
					return;
				}
			}

			this.setPosition(x,y);

			// We must be touching the new tile, so act on that.
			if( tileType.onTouch ) {
				tileType.onTouch(this,adhoc(tileType,x,y));
			}

			let f = new ItemFinder(this.map.itemList).at(x,y);
			for( let item of f.all ) {
				if( item.moveTo(this) !== false ) {
					tell(mSubject,this,' ',mVerb,'pick',' up ',mObject,item,'.');
					item.trigger(item,this);
				}
			}
		}
	}

	act() {
		if( this.isDead() ) {
			return;
		}

		if( this.regenerate ) {
			this.health = Math.min(this.health+this.regenerate,this.healthMax);
		}

		if( commandToDirection(this.command) !== false ) {
			let dir = commandToDirection(this.command);
			this.moveDir(dir);
		}
		else 
		switch( this.command ) {
			case Command.WAIT: {
				if( this.brain == 'user' ) {
					tell(mSubject,this,' ',mVerb,'wait','.');
				}
				let tileType = this.map.tileTypeGet(this.x,this.y);
				if( tileType.onTouch ) {
					tileType.onTouch(this,adhoc(tileType,this.x,this.y));
				}
				break;
			}
		};
	}
}
function isEntity(e) { return e instanceof Entity; }


// ITEM
let itemEffectCount = 0;

class Item {
	constructor(owner,itemType,position) {
		let inits = { owner: owner, id: humanNameList.pop(), x:position.x, y:position.y };
		Object.assign( this, itemType, inits );
		this.effect = this.effect===false ? false : this.generateEffect();
		this.name = this.namePattern.replace('*',this.effect.name);
	}
	generateEffect() {
		let effectTypeArray = Object.entries(EffectTypeList);
		let n = (itemEffectCount++)%effectTypeArray.length; //Math.randInt(0,effectTypeArray.length);
		return Object.assign({},effectTypeArray[n][1]);
	}
	moveTo(entity,x,y) {
		let ok = (!this.type.onPickup || this.type.onPickup(this,owner,entity)!==false);
		if( !ok ) {
			return false;
		}
		this.owner.itemRemove(this);	

		this.x = x;
		this.y = y;
		this.owner = entity;
		this.owner.itemTake(this);
		return true;
	}
	trigger(cause,target) {
		if( this.effect===false ) {
			return false;
		}
		//add(cause,entity,duration,stat,op,value,onTick,onEnd,data) {
		// Here is where we should figure out the area of effect and hit all as needed.
		let effect = this.effect;
		this.x = target.x;
		this.y = target.y;
		if( effect.requires && !effect.requires(target) ) {
			tell(mSubject,this,' has no effect on ',mObject,target);
		}
		this.cause = cause;
		deedAdd(this,target,rollDice(effect.duration),effect.stat,effect.op,rollDice(effect.value),effect.onTick,effect.onEnd);
		this.charges -= 1;
		if( this.charges < 0 ) {
			this.owner.itemRemove(this);
		}
	}
}

// MAP

class Map {
	constructor(tile,itemList) {
		this.isMap = true;
		this.tile = tile;
		this.itemList = itemList;
		while( tile[tile.length-1].trim() == '' ) {
			tile.length -= 1;
		}
		this.xLen = tile[0].length;
		this.yLen = tile.length;
	}
	setDimensions(xLen,yLen) {
		this.xLen = xLen;
		this.yLen = yLen;
	}
	inBounds(x,y) {
		return x>=0 && x<this.xLen && y>=0 && y<this.yLen;
	}
	tileSymbolSet(x,y,tileType) {
		if( !this.inBounds(x,y) ) {
			debugger;
		}
		this.tile[y] = this.tile[y].substr(0,x)+tileType.symbol+this.tile[y].substr(x+1);
	}
	tileSymbolGet(x,y) {
		if( !this.inBounds(x,y) ) { debugger; }
		return this.tile[y].charAt(x);
	}
	tileTypeGet(x,y) {
		let symbol = this.tileSymbolGet(x,y);
		return ( this.inBounds(x,y) ? SymbolToType[symbol] : false );
	}
	tileTypeGetDir(x,y,dir) {
		x += DirectionAdd[dir].x;
		y += DirectionAdd[dir].y;
		return this.tileTypeGet(x,y);
	}
	itemRemove(item) {
		if( !this.itemList.includes(item) ) {
			debuger;
		}
		Array.filterInPlace( this.itemList, i => i.id!=item.id )
		this.tileSymbolSet(item.x,item.y,TileTypeList['floor']);
	}
	itemTake(item) {
		if( this.itemList.includes(item) ) {
			debuger;
		}
		this.itemList.push(item);
		this.tileSymbolSet(item.x,item.y,item.symbol);
	}
}

function calcVis(map,px,py,sightDistance,blind,cachedVis) {

	function shoot(sx,sy,tx,ty) {
		if( sx==tx && sy==ty ) {
			return true;
		}
		if( blind ) {
			return false;
		}
		let sxInt = Math.floor(sx);
		let syInt = Math.floor(sy);
		let dx = tx-sx;
		let dy = ty-sy;
		let dist = Math.sqrt(dx*dx+dy*dy);
		let x = sx;
		let y = sy;
		let step = 0.25;
		dx = dx / (dist/step);
		dy = dy / (dist/step);
		// Always allowed to see itself.
		dist -= 0.5;
		let wallAmount = 0; //let bad = {x:0,y:0,count:0};
		while( dist > 0 ) {
			let xInt = Math.floor(x);
			let yInt = Math.floor(y);
			let atPlayer = (xInt==px && yInt==py);
			if( !atPlayer ) {
				wallAmount += map.tileTypeGet(xInt,yInt).opacity;
				if( wallAmount >= 1 ) { return false; }
			}
			x += dx;
			y += dy;
			dist -= step;
		}
		return true;
	}

	let a = cachedVis || [];

	for( let y=0 ; y<map.yLen ; ++y ) {
		a[y] = a[y] || [];
		for( let x=0 ; x<map.xLen ; ++x ) {
			if( Math.abs(y-py)>sightDistance || Math.abs(x-px)>sightDistance ) {
				a[y][x] = false;
			}
			let tl = shoot(px,py,x,y);
			let tr = shoot(px+0.95,py+0.00,x+0.95,y+0.00);
			let bl = shoot(px+0.00,py+0.95,x+0.00,y+0.95);
			let br = shoot(px+0.95,py+0.95,x+0.95,y+0.95);
			let isVisible = tl || tr || bl || br;
			a[y][x] = isVisible;
		}
	}
	a[py][px] = true;
	return a;
}


// READOUT

class Readout {
	constructor() {
		this.lastHealth = [];
	}
	render(entityList) {
		let player = entityList.find( entity => entity.brain=="user" );
		if( !player ) { return; }

		let f = player.entityFinder().prepend(player).canPerceive().byDistance().keepTop(5);

		for( let i=0 ; i<5 ; ++i ) {
			if( i >= f.all.length ) {
				$('#health'+i).hide();
				continue;
			}
			let entity = f.all[i];
			let newValue = entity.health;
			let lastValue = this.lastHealth[entity.id]!==undefined ? this.lastHealth[entity.id] : newValue;
			$('#health'+i).show();
			showHealthBar('#health'+i,newValue,lastValue,entity.healthMax,entity.name);
			this.lastHealth[entity.id] = newValue;
		}
	}
}


function renderToString(observer,map,entityList) {

	// Recalc this here, just in case.
	let a = observer.calcVis();
	let s = '';
	let p = [];
	for( let entity of entityList ) {
		if( observer.canPerceive(entity) ) {
			let symbol = ( entity.id == observer.id && observer.invisible ) ? selfInvisibilitySymbol : entity.symbol;
			p[entity.y*map.xLen+entity.x] = symbol;
		}
	}

	for( let y=0 ; y<map.yLen ; ++y ) {
		for( let x=0 ; x<map.xLen ; ++x ) {
			let vis = a[y][x];
			if( vis === false ) {
				s += ' ';
				continue;
			}
			s += p[y*map.xLen+x] || map.tile[y][x];
		}
		s += '\n';
	}
	return s;
}



// INIT GAME DATA

function initGameData(tileRaw) {

	let itemList = [];
	let map = new Map(tileRaw.split('\n'),itemList);
	let entityList = [];
	for( let y=0 ; y<map.yLen ; ++y ) {
		for( let x=0 ; x<map.xLen ; ++x ) {
			// Note that this code uses the SIMPLEST function that do NOT assume
			// what is on the map...
			let symbol = map.tileSymbolGet(x,y);
			let entityType = SymbolToType[symbol];
			if( !entityType ) {
				debugger;
			}
			if( entityType && entityType.isMonsterType ) {
				let fnName = entityType.brain == 'user' ? 'unshift' : 'push';
				entityList[fnName]( new Entity( map, entityList, entityType, { x:x, y:y } ) );
				map.tileSymbolSet(x,y,TileTypeList.floor)
			}
			if( entityType && entityType.isItemType ) {
				itemList.push( new Item( map, entityType, { x:x, y:y } ) );
			}
		}
	}

	// When there is only one monster, we are probably testing, so watch it.
	if( entityList.length == 2 ) {
		// zero will be the player
		entityList[entityList.length-1].watch = true;
	}
	return { map, entityList, itemList };
}

function main(levelName) {

	function playerFind() {
		return entityList.find( entity => entity.brain==Brain.USER );
	}

	function render() {
		let player = playerFind();
		document.getElementById('map').innerHTML = renderToString(player,map,entityList);
		readout.render(entityList);
	}

	function testVictory() {
		let player = playerFind();
		if( player ) {
			let entityType = map.tileTypeGet(player.x,player.y);
			if( entityType.isStairs ) {
				tell('Congratulations! ',mSubject,player,' ',mVerb,'descend',' the stairs to victory!');
				player.isVictorious = true;
			}
		}
	}

	function checkDeaths() {
		Array.filterInPlace( entityList, entity => {
			if( entity.isDead() ) {
				entity.die();
				return false;
			}
			return true;
		});
	}

	function tick(player) {
		let dt = 1 / player.speed;
		for( let entity of entityList ) {
			DeedManager.tick(entity,dt);
			entity.actionCount += entity.speed / player.speed;
			while( entity.actionCount >= 1 ) {
				entity.calcVis();
				entity.think();
				entity.act();
				DeedManager.calc(entity);
				entity.actionCount -= 1;
			}
		}
		DeedManager.cleanup();
		testVictory();
		checkDeaths();
		entityList.forEach( entity => { entity.commandLast = entity.command; entity.command = Command.NONE; } );
		render();
	}

	function messageCanPerceive(observer,x,y) {
		if( !observer ) {
			return true;
		}
		return observer.canPerceive(x,y);
	}

	function messageReceive(message,history) {
		while( history.length > 10 ) {
			history.pop();
		}
		let targetElement = document.getElementById('messageBox');
		targetElement.innerHTML = (history[5]||'')+'\n'+(history[4]||'')+'\n'+(history[3]||'')+'\n'+(history[2]||'')+'\n'+(history[1]||'')+'\n'+(history[0]||'');
		targetElement.scrollTop = targetElement.scrollHeight
	}

	function onPlayerKey(e) {
		// let keyUp=38, keyDown=40, keyLeft=37, keyRight=39;
		let KeyToCommand = loadKeyMapping("default");

		let player = playerFind();
		if( player && !player.isDead() ) {
			player.command = KeyToCommand[''+e.keyCode] !== undefined ? KeyToCommand[''+e.keyCode] : Command.NONE;

			if( player.command !== Command.NONE ) {
				tick(player);
			}
		}
	}


	let {map: map, entityList: entityList, itemList:itemList} = initGameData( loadLevel(levelName) );
	let readout = new Readout();
	let player = playerFind();
	MessageManager.addRecipient(player,messageCanPerceive,messageReceive);
	document.addEventListener( "keydown", onPlayerKey, false );

	render();
	tell([player,null,"Welcome to flogue! Use the arrow keys to move, and '.' to wait. Reach the > stairs!"]);
	tell(mSubject,player,' ',mVerb,'step',' through the doorway...');
	// The tick is called each time the player takes an action.
}

(function() {

	// Ǿgidᵬj  AB*? ᵮ⍨|:░ ¡$

	let level = { 
		"test":
			"#################\n"+
			"#   #####⍨⍨⍨?BA*#\n"+
			"#   |  ᵮ¡¡¡¡¡@  #\n"+
			"#   # ### ¡¡¡ ᵮ #\n"+
			"#ᵮᵮᵮ# # ¡¡¡¡¡ $ #\n"+
			"#   # #:::      #\n"+
			"#   # #::: ░░░░░#\n"+
			"#   # #::: ░░░░░#\n"+
			"#################\n"+
			'',
		"real":
			"###################         ##########\n"+
			"#>i+ggᵮ           ######### #     ᵬ  #\n"+
			"####ggᵮ           #       # #⍨⍨⍨####j#\n"+
			"   #ggᵮ           # ##### # #⍨⍨⍨#### #\n"+
			"  #####           # | * |g###⍨⍨⍨#*## #\n"+
			"  #Ǿ  ##+#      ᵬ + ##### +  g       #\n"+
			"  #      #   d@   ###   ##############\n"+
			"  #+##########Ώ## #     #  ::::::::#  \n"+
			"  #░░░░░░░░#    # #     #  ᵮᵮᵮᵬᵬᵬ::#  \n"+
			"  ####░░░░░#    # #######  :::::ᵬ::#  \n"+
			"     #░░░░░##   #          ::::gAᵬ:#  \n"+
			"     #░░░pp*#   ####################  \n"+
			"     ########                         \n"+
			''
	};
	window.loadLevel = function(levelName) {
		return level[levelName] ? level[levelName] : level["real"];
	}
})();


function loadKeyMapping(name) {
	return {
		38: Command.N,
		37: Command.W,
		40: Command.S,
		39: Command.E,
		74: Command.N,
		85: Command.NE,
		76: Command.E,
		78: Command.SE,
		75: Command.S,
		66: Command.SW,
		72: Command.W,
		89: Command.NW,
		190: Command.WAIT
	};
}

</script>
</head>
<body>
	<table>
		<tr><td colspan="2">
			<div id="messageBox"></div>
		</td></tr>
		<tr>
			<td>
				<div id="map"></div>
			</td><td>
				<div id="readout">
					<div id='health0' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health1' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health2' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health3' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health4' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
				</div>
			</td>
		</tr>
	</table>
	<script>
		main("test");
	</script>
</body>
</html>
