<html>
<head>
<meta charset="utf-8"/>
<!-- link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/minireset.css/0.0.2/minireset.css"-->
<link rel="stylesheet" type="text/css" href="minireset.css">
<link rel="stylesheet" type="text/css" href="index.css">
<!--script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script-->
<script src="jquery.3.3.1.js"></script>
<script src="pixi.min.js"></script>
<script src="nameList.js"></script>
<script src="utilities.js"></script>
<script src="data.js"></script>
<script src="places.js"></script>
<script src="mason.js"></script>
<script src="deed.js"></script>
<script src="map.js"></script>
<script src="item.js"></script>
<script src="entity.js"></script>
<script src="anim.js"></script>
<script src="tell.js"></script>
<script src="readout.js"></script>
<script src="display.js"></script>
<script src="sentence.js"></script>
<script src="finder.js"></script>
<qscript src="levels.js"></script>
<script>

/*
Resources:
* https://opengameart.org/content/2d-dungeon-and-roguelike-1
* https://opengameart.org/content/2d-32x32


*/

let humanNameList = Array.shuffle(getNameList());

function bonk(entity,target) {
	tell( mSubject, entity, ' ', mVerb, 'run', ' into ', mObject, target, '.' );
}


function adhoc(tileType,x,y) {
	if( tileType.isItemType ) {
		// You only need to make adhoc versions of TILES, because they lack (x,y) coords.
		// This also means no permanent data can exist in them. Meanwhile, items and
		// persistent in the map item list.
		return tileType;
	}
	return Object.assign({},tileType,{x:x,y:y});
}

function objHas(obj,member) {
	return( typeof obj=='object' && obj[member] !== undefined );
}




function clearCommands(entityList) {
	entityList.forEach( entity => {
		entity.commandLast = entity.command;
		entity.commandItemLast = entity.commandItem;
		entity.commandTargetLast = entity.commandTarget;
		entity.command = Command.NONE;
		entity.commandItem = null;
		entity.commandTarget = null;
	});
}

function playerFind(entityList) {
	return entityList.find( entity => entity.isUser() );
}

function checkDeaths(entityList) {
	Array.filterInPlace( entityList, entity => {
		if( entity.isDead() ) {
			entity.die();
			return entity.isUser();	// do not remove the player from the entity list.
		}
		return true;
	});
}

function testVictory(map,entityList) {
	let player = playerFind(entityList);
	if( player ) {
		let entityType = map.tileTypeGet(player.x,player.y);
		if( entityType.isStairs ) {
			tell('Congratulations! ',mSubject,player,' ',mVerb,'descend',' the stairs to victory!');
			player.isVictorious = true;
		}
	}
}

function orderByTurn(entityList) {
	let list = [[],[],[]];	// players, pets, others
	entityList.map( entity => {
		let group = ( entity.isUser() ? 0 : (entity.brainPet && entity.team==Team.GOOD ? 1 : 2 ));
		list[group].push(entity);
	});
	list[2].sort( (a,b) => a.speed-b.speed );
	return [].concat(list[0],list[1],list[2]);
}

function tickItemList(itemList,dt,map,entityList) {
	for( let item of itemList ) {
		if( item.rechargeLeft > 0 ) {
			item.rechargeLeft = Math.max(0,item.rechargeLeft-1);
		}
		if( item.onTick ) {
			item.onTick.call(item,dt,map,entityList);
		}
	}
}

function prepareStaticData() {
	SymbolToType = (function() {
		let lookup = {};
		Object.entries(StickerList).forEach( ([typeId,sticker]) => {
			sticker.isSticker = true;
			sticker.typeId = typeId;
			if( sticker.symbol ) {
				lookup[sticker.symbol] = sticker;
			}
			sticker.type = sticker;
		} );
		Object.entries(TileTypeList).forEach( ([typeId,tileType]) => {
			tileType.isTileType = true;
			tileType.typeId = typeId;
			lookup[tileType.symbol] = tileType;
			tileType.type = tileType;
		} );
		Object.entries(ItemTypeList).forEach( ([typeId,itemType]) =>  {
			itemType.isItemType = true;
			itemType.typeId = typeId;
			itemType.namePattern = itemType.namePattern || typeId;
			ItemTypeList[typeId] = Object.assign( {}, ItemTypeDefaults, ItemTypeList[typeId] );
			lookup[itemType.symbol] = ItemTypeList[typeId];
			ItemTypeList[typeId].type = ItemTypeList[typeId];
		} );
		Object.entries(MonsterTypeList).forEach( ([typeId,monsterType]) =>  {
			monsterType.isMonsterType = true;
			monsterType.typeId = typeId;
			MonsterTypeList[typeId].name = MonsterTypeList[typeId].name || typeId;
			MonsterTypeList[typeId] = Object.assign( {}, MonsterTypeDefaults, MonsterTypeList[typeId] );
			lookup[monsterType.symbol] = MonsterTypeList[typeId];
			MonsterTypeList[typeId].type = MonsterTypeList[typeId];
		} );
		return lookup;
	})();
}

class PlaceManager {
	constructor(placeSourceList) {
		this.placeSourceList = placeSourceList;
		this.symbolToType = null;
		this.typeToSymbol = null;
	}

	preparePlaceForInjection(place) {

		// If any of the symbols are pickable, get that done.
		for( let s in place.symbols ) {
			if( typeof place.symbols[s] == 'function' ) {
				place.symbols[s] = place.symbols[s].call(place);
			}
		}

		// Replace map symbols with allocated symbols
		place.mapOriginal = place.map.trim();
		let map = '';
		for( let i=0 ; i<place.mapOriginal.length ; ++i ) {
			let s = place.mapOriginal.charAt(i);
			if( s=='\t' ) { continue; }
			if( s=='\n' ) { map+=s; continue; }
			let mappedToTypeId = place.symbols[s];
			// Check if the place chose to used ad-hoc symbology for something
			if( mappedToTypeId ) {
				s = this.typeToSymbol[mappedToTypeId];
			}
			if( !this.symbolToType[s] ) debugger;	// By now we should have resolved what this symbol maps to
			map += s;
		}
		place.map = new SimpleMap(map);

		if( place.flags && place.flags.rotate ) {
			place.map.rotate(Math.randInt(0,4));
		}
	}

	integratePlaceData() {

		let s2t = {};
		let t2s = {};
		function extract() {
			for( let typeList of arguments ) {
				for( let t in typeList ) {
					let s = typeList[t].symbol;
					s2t[s] = t;
					t2s[t] = s;
				}
			}
		}
		extract(TileTypeList,ItemTypeList,MonsterTypeList);
		if( s2t[TILE_UNKNOWN] ) {
			// WARNING: I'm reserving the ' ' symbol to mean 'nothing here, replaceable' in a place map.
			debugger;
		}

		let sIndex = 32+1;
		function getUnusedSymbol() {
			while( s2t[String.fromCharCode(sIndex)] ) {
				++sIndex;
			}
			return String.fromCharCode(sIndex);
		}

		// Give symbols to anything that lacks a symbol.
		for( let placeId in this.placeSourceList ) {

			let place = this.placeSourceList[placeId];	// make a copy so that we can mangle it.
			place.id = placeId;
			let roster = Object.assign({},place.monsterTypes,place.itemTypes,place.tileTypes);
			for( let typeId in roster ) {
				// If there is no symbol in the existing corpus...
				if( !t2s[typeId] ) {
					let s = getUnusedSymbol();
					t2s[typeId] = s;
					s2t[s] = typeId;
				}
			}

			Object.assign(StickerList,		place.stickers);
			Object.assign(DamageType,		place.damageType);
			Object.assign(Attitude,			place.attitude);
			Object.assign(PickImmune,		place.pickImmune);
			Object.assign(PickResist,		place.pickResist);
			Object.assign(EffectTypeList,	place.effectList);

			function processTypeList(targetList,typeList) {
				for( let typeId in typeList ) {
					let type = typeList[typeId];
					let targetType = targetList[typeId];
					let newType = Object.assign( {}, type.basis ? targetList[type.basis] || {} : {}, targetType || {}, type, {symbol:t2s[typeId]} );
					targetList[typeId] = newType;
				}
			}
			processTypeList( TileTypeList, 		place.tileTypes );
			processTypeList( ItemTypeList,		place.itemTypes );
			processTypeList( MonsterTypeList,	place.monsterTypes );
		}
		this.symbolToType = s2t;
		this.typeToSymbol = t2s;
	}
	injectPlaces(map,numPlaces) {
		let self = this;
		let entityInject = {};
		let placeReps = numPlaces;
		while( placeReps-- ) {
			let place = Object.assign( {}, pick(this.placeSourceList) );
			console.log("Trying place "+place.id);
			this.preparePlaceForInjection(place);
			let fitReps = 300;
			let x,y;
			do {
				[x,y] = map.pickPos(0,0,place.map.xLen,place.map.yLen);
				console.log('('+x+','+y+')');
			} while( !map.fit(x,y,place.map) && --fitReps );
			if( fitReps ) {
				map.inject(x,y,place.map,function(x,y,symbol) {
					let typeId = self.symbolToType[symbol];
					if( !typeId ) debugger;
					if( place.onEntityCreate && place.onEntityCreate[typeId] ) {
						entityInject[''+x+','+y] = place.onEntityCreate[typeId];
					}
				});
			}
		}
		return entityInject;
	}
}

// INIT GAME DATA

function initGameData(tileRaw,placeManager,numPlacesToInject) {

	let itemList = [];
	let map = new Map(tileRaw,itemList);
	let entityInject = placeManager.injectPlaces(map,numPlacesToInject);

	let entityList = [];
	for( let y=0 ; y<map.yLen ; ++y ) {
		for( let x=0 ; x<map.xLen ; ++x ) {
			// Note that this code uses the SIMPLEST function that do NOT assume
			// what is on the map...
			let symbol = map.tileSymbolGet(x,y);
			let entityType = SymbolToType[symbol];
			if( !entityType ) {
				debugger;
			}
			let inject = entityInject[''+x+','+y] || {};
			if( entityType && entityType.isMonsterType ) {
				let fnName = entityType.brain == 'user' ? 'unshift' : 'push';
				entityList[fnName]( new Entity( map, entityList, entityType, { x:x, y:y }, inject ) );
				map.tileSymbolSet(x,y,TileTypeList.floor.symbol)
			}
			if( entityType && entityType.isItemType ) {
				if( entityType.isRandom ) {
					let itemTypeArray = Object.entries(ItemTypeList);
					// WARNING: This assumes that RANDOM is the zeroth element!!
					let n = Math.randInt(1,itemTypeArray.length);
					entityType = itemTypeArray[n][1];
				}
				itemList.push( new Item( map, entityType, { x:x, y:y }, inject ) );
				// WARNING: We could set this more carefully, like by checking around it and using majority
				// of passable tiles.
				map.tileSymbolSet(x,y,TileTypeList.floor.symbol);
			}
		}
	}

	// When there is only one monster, we are probably testing, so watch it.
	if( entityList.length == 2 ) {
		// zero will be the player
		entityList[entityList.length-1].watch = true;
	}
	return { map, entityList, itemList };
}

function main(levelName) {

	function render(observer) {
		readout.render(observer,entityList);
		let drawList = createDrawList(observer,map,entityList);
		display.draw(drawList,observer);
	}

	function tick(speed) {

		let entityListByTurnOrder = orderByTurn(entityList);
		let dt = 1 / speed;
		for( let entity of entityListByTurnOrder ) {
			DeedManager.tick(entity,dt);
			entity.actionCount += entity.speed / speed;
			while( entity.actionCount >= 1 ) {
				entity.calcVis();
				entity.think();
				entity.act();
				tickItemList(entity.inventory,dt,map,entityList);
				DeedManager.calc(entity);
				entity.actionCount -= 1;
			}
		}
		map.actionCount += 1 / speed;
		while( map.actionCount >= 1 ) {
			tickItemList(map.itemList,dt,map,entityList);
			map.actionCount -= 1;
		}
		DeedManager.cleanup();
		testVictory(map,entityList);
		checkDeaths(entityList);
		clearCommands(entityList);
	}

	function messageCanPerceiveEntity(observer,entity) {
		if( !observer ) {
			return true;
		}
		return observer.canPerceiveEntity(entity);
	}

	function messageReceive(message,history) {
		while( history.length > 10 ) {
			history.pop();
		}
		let targetElement = document.getElementById('messageBox');
		targetElement.innerHTML = (history[5]||'')+'\n'+(history[4]||'')+'\n'+(history[3]||'')+'\n'+(history[2]||'')+'\n'+(history[1]||'')+'\n'+(history[0]||'');
		targetElement.scrollTop = targetElement.scrollHeight
	}

	function onPlayerKey(e) {
		// let keyUp=38, keyDown=40, keyLeft=37, keyRight=39;
		let KeyToCommand = loadKeyMapping("default");

		let player = playerFind(entityList);
		if( !player || player.isDead() ) {
			tick(1.0);
			render(player || spectator);
		}
		else {
			player.command = KeyToCommand[''+e.keyCode] !== undefined ? KeyToCommand[''+e.keyCode] : Command.NONE;

			let timePass = readout.evalCommand(player,e.keyCode,player.command);
			if( timePass && player.command !== Command.NONE ) {
				tick(player.speed);
			}
			render(player);
			spectator.x = player.x;
			spectator.y = player.y;
		}
	}

	function worldOverlayAdd(group,x,y,sticker) {
		return animationAdd( new AniPaste({ group:group, x:x, y:y, sticker:sticker, duration: true }) );
	}
	function worldOverlayRemove(fn) {
		return animationRemove(fn);
	}

	let placeManager = new PlaceManager(loadPlaceList());
	placeManager.integratePlaceData();
	prepareStaticData();

	//let mapRaw = buildLevel(80,TileTypeList,MonsterTypeList,ItemTypeList);
	let mapRaw = loadLevel(levelName);
	let {map: map, entityList: entityList, itemList:itemList} = initGameData( mapRaw, placeManager, 0 );
	let display = new Display('map',MonsterTypeDefaults.sightDistance);
	let readout = new Readout('readoutSpells','inventory',worldOverlayAdd,worldOverlayRemove);
	let player = playerFind(entityList);
	let spectator = {
		x: 0,
		y: 0,
		vis: [],
		canPerceiveEntity: () => true,
		calcVis: () => calcVis(map,spectator.x,spectator.y,MonsterTypeDefaults.sightDistance,false,spectator.vis)
	};
	MessageManager.addRecipient(player,messageCanPerceiveEntity,messageReceive);

	let handle = setInterval(function() {
		if( !display.ready ) {
			return;
		}
		clearInterval(handle);
		document.addEventListener( "keydown", onPlayerKey, false );

		render(player);
		tell([player,null,"Welcome to flogue! Use the arrow keys to move, and '.' to wait. Reach the > stairs!"]);
		tell(mSubject,player,' ',mVerb,'step',' through the doorway...');
		// The tick is called each time the player takes an action.
	}, 20);
}

(function() {

	// Ǿgidᵬje  AB*? ᵮ⍨|:░ ¡$

	let level = {
		"test":
			"############\n"+
			"#@ ¡       #\n"+
			"#          #\n"+
			"#ᵮA ¡¡¡¡¡  #\n"+
			"# ᵴ        #\n"+
			"#  ~~~~    #\n"+
			"#  ~~~~    #\n"+
			"############\n"+
			'',
		"all":
 			"#######################\n"+
			"#Ǿ#g#s#k#e#T#v#ᵬ#f#i#r#\n"+
			"#±#±#±#±#±#±#±#±#±#±#±#\n"+
			"#                     #\n"+
			"# :::                 #\n"+
			"# :::                 #\n"+
			"# ⍨⍨⍨       g ᵴ@      #\n"+
			"# ᵮᵮᵮ            AB?F##\n"+
			"#              ########\n"+
			"#              + ░░░░░#\n"+
			"# $ ††         | ░░░░░#\n"+
			"# ᵴᵴᵴᵴᵴᵴᵴᵴᵴᵴᵴ  ± ░░░░░#\n"+
			"#¡¡¡¡¡¡¡¡¡¡¡¡  # ░░░░>#\n"+
			"#######################\n"+
			'',
		"real":
			"###################         ##########\n"+
			"#>i+*gᵮ     *  * ?######### # ¡¡  ᵬ  #\n"+
			"####  ᵮ           #     g # #⍨⍨⍨####v#\n"+
			"   #ggᵮ      kk   # ##### # #⍨⍨⍨#### #\n"+
			"  #####           # | A | ###⍨⍨⍨#*## #\n"+
			"  #Ǿ ¡##+#      ᵬ ± ##### +  g       #\n"+
			"  #      #   d@   ###***##############\n"+
			"  #+##########Ώ## #B    #¡ ::::::::#  \n"+
			"  #░░░░░░░░#    # #     #  ᵮᵮᵮᵬᵬᵬ::#  \n"+
			"  ####░░░░░#    # ###±###  :::::ᵬ::#  \n"+
			"     #░░░░░##   #          ::::g ᵬ:#  \n"+
			"     #e░░ffF#   # #############   ##  \n"+
			"     ########   # #           #   #   \n"+
			"                # #           #   #   \n"+
			"        ######### ######      # A #   \n"+
			"        #    |     ::  #      #####   \n"+
			"        #    |     ::  #              \n"+
			"        #e   |     ::  #              \n"+
			"        #¡   |     ::  #              \n"+
			"        #¡¡¡ |     ::  #              \n"+
			"        ################              \n"+
			'',
		"huge":
			"##########################################\n"+
			"#                                        #\n"+
			"#  @                                     #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"#                                        #\n"+
			"##########################################\n"+
			'',

	};
	window.loadLevel = function(levelName) {
		return level[levelName] ? level[levelName] : level["real"];
	}
})();


function loadKeyMapping(name) {
	return {
		38: Command.N,
		37: Command.W,
		40: Command.S,
		39: Command.E,
		74: Command.S,
		85: Command.NE,
		76: Command.E,
		78: Command.SE,
		75: Command.N,
		66: Command.SW,
		72: Command.W,
		89: Command.NW,
		73: Command.INVENTORY,
		81: Command.QUAFF,
		84: Command.THROW,
		67: Command.CAST,
		112: Command.CAST1,
		113: Command.CAST2,
		114: Command.CAST3,
		115: Command.CAST4,
		116: Command.CAST5,
		190: Command.WAIT
	};
}

</script>
</head>
<body>
	<table>
		<tr><td colspan="2">
			<div id="messageBox"></div>
		</td></tr>
		<tr>
			<td>
				<div id="mapContainer">
					<div id="map"></div>
					<div id="inventory"></div>
				</div>
			</td><td>
				<div id="readoutStatus">
					<div id='health0' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health1' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health2' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health3' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health4' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health5' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health6' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health7' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health8' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health9' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
				</div>
				<div id="readoutSpells">
				</div>
			</td>
		</tr>
	</table>
	<script>
		main("test");
	</script>
</body>
</html>
