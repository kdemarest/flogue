<html>
<head>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/minireset.css/0.0.2/minireset.css">

<style>
body {
	overflow-x: hidden;
	overflow-y: hidden;
}
#map {
	display: block;
	white-space: pre;
	font-family: "Courier New", Courier, sans-serif;
	font-size: 18px;
	line-height: 18px;
	margin-left: 10px;
	margin-top: 10px;
	border: 1px solid black;
	width: 500px;
	height: 500px;
}
#messageBox {
	display: block;
	white-space: pre;
	font-family: "Ariel", serif;
	font-size: 16px;
	line-height: 16px;
	height: 48px;
	width: 100%;
	margin: 0px 0px;
	overflow-y: scroll;
	overflow-x: auto;
	margin-bottom: 10px;
}
</style>

<script>

// STATIC UTILITY FUNCTIONS

(function(){
	Math.clamp = function(value,min,max) {
		return Math.max(min,Math.min(max,value));
	}

	Math.randInt = function(min, max) {
		return Math.floor(Math.random() * (max - min)) + min;
	}
	Math.rand = function(min, max) {
		return Math.random()*(max-min)+min;
	}
	Array.filterInPlace = function(a, condition, thisArg) {
		let j = 0;

		a.forEach((e, i) => { 
			if (condition.call(thisArg, e, i, a)) {
				if (i!==j) a[j] = e; 
				j++;
			}
		});

		a.length = j;
	return a;
	}
})();

// STATIC DATA

const Command = { NONE: "none", UP:"goUp", RIGHT: "goRight", DOWN: "goDown", LEFT: "goLeft", WAIT: "wait", QUIT: "quit" };
function commandToDir(c) {
	return c==Command.UP ? 0 : c==Command.RIGHT ? 1 : c==Command.DOWN ? 2 : c==Command.LEFT ? 3 : false;
}
const Direction = [{x:0,y:-1,c:Command.UP},{x:1,y:0,c:Command.RIGHT},{x:0,y:1,c:Command.DOWN},{x:-1,y:0,c:Command.LEFT}];
const DirectionCount = 4;
const TileTypeList = {
	"floor":     { symbol: ' ', mayWalk: true, name: "floor" },
	"wall":      { symbol: '#', mayWalk: false, name: "wall" },
	"shut door": { symbol: 'Ώ', mayWalk: false, name: "shut door" },
	"stairs":    { symbol: '>', mayWalk: true, name: "staircase", isStairs: true },
};
const MonsterTypeList = {
	"goblin": { symbol: 'g', healthMax: 10, damage: '1d4', brain: "monster", name: "goblin" },
	"player": { symbol: '@', healthMax: 20, damage: '1d3+2', brain: "user", name: "player" }
};

const SymbolToType = (function() {
	let lookup = {};
	Object.entries(TileTypeList).forEach( ([id,tileType]) => { tileType.type = 'tile'; lookup[tileType.symbol] = tileType; } );
	Object.entries(MonsterTypeList).forEach( ([id,monsterType]) =>  { monsterType.type = 'monster'; lookup[monsterType.symbol] = monsterType; } );
	return lookup;
})();

// ENTITY (monsters, players etc)

class Entity {
	constructor(map,entityList,monsterType,position) {
		Object.assign( this, monsterType, { x:position.x, y:position.y, map: map, entityList:entityList, health: monsterType.healthMax, command: Command.NONE } );
	}

	die() {
		if( this.isVictorious ) {
			return;
		}
		if( this.removed ) {
			debugger;
		}
		tell(this.name+' dies!');
		this.removed = true;
	}

	isDead() {
		return this.removed || this.isVictorious || this.health <= 0;
	}

	enemyAtPos(x,y,exclude) {
		return this.entityList.find( entity => entity.x==x && entity.y==y && entity!=exclude);
	}

	enemyAtDir(dir,exclude) {
		let x = this.x + Direction[dir].x;
		let y = this.y + Direction[dir].y;
		return this.enemyAtPos(x,y,exclude);
	}

	think() {

		if( this.brain == "monster" ) {
			this.command = Command.WAIT;
			for( let dir=0 ; dir<DirectionCount ; ++dir ) {
				if( this.enemyAtDir(dir) ) {
					this.command = Direction[dir].c;
					break;
				}
			}
			if( this.command == Command.WAIT ) {
				const RandCommand = [Command.UP, Command.RIGHT, Command.DOWN, Command.LEFT];
				let reps = 4;
				do {
					this.command = RandCommand[Math.randInt(0,RandCommand.length)];
					let dir = commandToDir(this.command);
					if( dir !== false ) {
						let targetType = this.map.entityGetDir(this.x,this.y,dir);
						if( targetType.mayWalk ) {
							break;
						}
					}
				} while( --reps );
				if( !reps ) { this.command = Command.WAIT; }
			}
		}

		if( this.brain == "player" ) {
			// Placeholder, since the onPlayerKey already sets the command for us
		}
	}

	rollDamage(damageString) {
		let parts = damageString.split( /[d\+]/ );
		let numDice = parseInt(parts[0]);
		let dieFaces = parseInt(parts[1]);
		let plus = parseInt(parts[2]);
		let damage = plus || 0;
		while( numDice-- ) { damage += Math.randInt(1,dieFaces+1); }
		return damage;
	}

	attack(other) {
		let damage = this.rollDamage(this.damage);
		tell(this.name+' hit '+other.name+' for '+damage+' damage!')
		other.health -= damage;
	}

	setPosition(x,y) {
		this.x = x;
		this.y = y;
	}

	moveDir(dir) {
		let xAdd = Direction[dir].x;
		let yAdd = Direction[dir].y;
		let x = this.x + xAdd;
		let y = this.y + yAdd;
		if( this.map.inBounds(x,y) ) {
			let other = this.enemyAtPos(x,y,this);
			if( other ) {
				this.attack(other);
				if( !other.isDead() ) {
					return;
				}
			}
			let symbol = this.map.tileSymbolGet(x,y);
			let entityType = SymbolToType[symbol];
			if( entityType.mayWalk ) {
				this.setPosition(x,y);
			}
			else {
				tell(this.name+" runs into a "+entityType.name)
			}
		}
	}

	act() {
		switch( this.command ) {
			case Command.UP: {
				this.moveDir(0);
				break;
			}
			case Command.RIGHT: {
				this.moveDir(1);
				break;
			}
			case Command.DOWN: {
				this.moveDir(2);
				break;
			}
			case Command.LEFT: {
				this.moveDir(3);
				break;
			}
			case Command.WAIT: {
				tell(this.name+' waits.');
				break;
			}
		};
	}
}

// MAP

class Map {
	constructor(tile) {
		this.tile = tile;
		this.xLen = tile[0].length;
		this.yLen = tile.length;
	}
	setDimensions(xLen,yLen) {
		this.xLen = xLen;
		this.yLen = yLen;
	}
	inBounds(x,y) {
		return x>=0 && x<this.xLen && y>=0 && y<this.yLen;
	}
	tileSymbolSet(x,y,tileType) {
		if( !this.inBounds(x,y) ) {
			debugger;
		}
		this.tile[y] = this.tile[y].substr(0,x)+tileType.symbol+this.tile[y].substr(x+1);
	}
	tileSymbolGet(x,y) {
		if( !this.inBounds(x,y) ) { debugger; }
		return this.tile[y].charAt(x);
	}
	entityGet(x,y) {
		let symbol = this.tileSymbolGet(x,y);
		return ( this.inBounds(x,y) ? SymbolToType[symbol] : false );
	}
	entityGetDir(x,y,dir) {
		x += Direction[dir].x;
		y += Direction[dir].y;
		return this.entityGet(x,y);
	}
}

let messageHistory = [];
function tell(message) {
	messageHistory.unshift(message);
	while( messageHistory.length > 10 ) { messageHistory.pop(); }
	document.getElementById('messageBox').innerHTML = (messageHistory[2]||'')+'\n'+(messageHistory[1]||'')+'\n'+(messageHistory[0]||'');
}

function renderToString(map,entityList) {
	let s = '';
	let p = [];
	for( let entity of entityList ) {
		p[entity.y*map.xLen+entity.x] = entity.symbol;
	}
	for( let y=0 ; y<map.yLen ; ++y ) {
		for( let x=0 ; x<map.xLen ; ++x ) {
			s += p[y*map.xLen+x] || map.tile[y][x];
		}
		s += '\n';
	}
	return s;
}



// INIT GAME DATA

function initGameData(tileRaw) {

	let map = new Map(tileRaw.trim().split('\n'));;
	let entityList = [];
	for( let y=0 ; y<map.yLen ; ++y ) {
		for( let x=0 ; x<map.xLen ; ++x ) {
			let entityType = SymbolToType[map.tileSymbolGet(x,y)];
			if( !entityType ) {
				debugger;
			}
			if( entityType && entityType.type == 'monster' ) {
				let fnName = entityType.brain == 'user' ? 'unshift' : 'push';
				entityList[fnName]( new Entity( map, entityList, entityType, { x:x, y:y } ) );
				map.tileSymbolSet(x,y,TileTypeList.floor)
			}
		}
	}
	return { map, entityList };
}

function loadGameData() {
	let map = 
		"########\n"+
		"#> g   #\n"+
		"###    #\n"+
		"  #   @#\n"+
		"  ####Ώ#\n"+
		'';
	return map;
}

function main() {

	function render() {
		document.getElementById('map').innerHTML = renderToString(map,entityList);
	}

	function testVictory() {
		let player = entityList.find( entity => entity.brain=="user" );
		if( player ) {
			let entityType = map.entityGet(player.x,player.y);
			if( entityType.isStairs ) {
				tell('Congratulations! You descend the stairs to victory!');
				player.isVictorious = true;
			}
		}
	}

	function checkDeaths() {
		Array.filterInPlace( entityList, entity => {
			if( entity.isDead() ) {
				entity.die();
				return false;
			}
			return true;
		});
	}

	function tick() {
		for( let entity of entityList ) {
			entity.think();
			entity.act();
		}
		testVictory();
		checkDeaths();
		entityList.forEach( entity => { entity.commandLast = entity.command; entity.command = Command.NONE; } );
		render();
	}

	function onPlayerKey(e) {
		// let keyUp=38, keyDown=40, keyLeft=37, keyRight=39;
		let KeyToCommand = {
			38: Command.UP,
			40: Command.DOWN,
			37: Command.LEFT,
			39: Command.RIGHT,
			190: Command.WAIT
		};

		let player = entityList.find( entity => entity.brain=="user" );
		if( !player.isDead() ) {
			player.command = KeyToCommand[''+e.keyCode] !== undefined ? KeyToCommand[''+e.keyCode] : Command.NONE;

			if( player.command !== Command.NONE ) {
				tick();
			}
		}
	}

	let {map: map, entityList: entityList} = initGameData( loadGameData() );
	document.addEventListener( "keydown", onPlayerKey, false );
	render();
	tell("Welcome to flogue! Use the arrow keys to move, and '.' to wait. Reach the > stairs!")
	// The tick is called each time the player takes an action.
}

</script>
</head>
<body>
	<div id="messageBox"></div>
	<div id="map"></div>
	<script>main();</script>
</body>
</html>
