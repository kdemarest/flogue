<html>
<head>
<meta charset="utf-8"/>
<!-- link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/minireset.css/0.0.2/minireset.css"-->
<link rel="stylesheet" type="text/css" href="minireset.css">
<link rel="stylesheet" type="text/css" href="index.css">
<!--script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script-->
<script src="jquery.3.3.1.js"></script>
<script src="pixi.min.js"></script>
<script src="nameList.js"></script>
<script src="utilities.js"></script>
<script src="data.js"></script>
<script src="picker.js"></script>
<script src="places.js"></script>
<script src="mason.js"></script>
<script src="deed.js"></script>
<script src="map.js"></script>
<script src="item.js"></script>
<script src="entity.js"></script>
<script src="anim.js"></script>
<script src="tell.js"></script>
<script src="readout.js"></script>
<script src="display.js"></script>
<script src="minimap.js"></script>
<script src="sentence.js"></script>
<script src="finder.js"></script>
<script src="dataConditioner.js"></script>
<script src="area.js"></script>
<script src="world.js"></script>
<qscript src="levels.js"></script>
<script>

/*
Resources:
* https://opengameart.org/content/2d-dungeon-and-roguelike-1
* https://opengameart.org/content/2d-32x32


*/

let humanNameList = Array.shuffle(getNameList());


function adhoc(tileType,x,y) {
	if( tileType.isItemType ) {
		// You only need to make adhoc versions of TILES, because they lack (x,y) coords.
		// This also means no permanent data can exist in them. Meanwhile, items and
		// persistent in the map item list.
		return tileType;
	}
	return Object.assign({},tileType,{x:x,y:y});
}


function clearCommands(entityList) {
	entityList.forEach( entity => {
		entity.commandLast = entity.command;
		entity.commandItemLast = entity.commandItem;
		entity.commandTargetLast = entity.commandTarget;
		entity.command = Command.NONE;
		entity.commandItem = null;
		entity.commandTarget = null;
	});
}

function playerFind(entityList) {
	return entityList.find( entity => entity.isUser() );
}

function checkDeaths(entityList) {
	Array.filterInPlace( entityList, entity => {
		if( entity.isDead() ) {
			entity.die();
			return entity.isUser();	// do not remove the player from the entity list.
		}
		return true;
	});
}

function orderByTurn(entityList) {
	let list = [[],[],[]];	// players, pets, others
	entityList.map( entity => {
		let group = ( entity.isUser() ? 0 : (entity.brainPet && entity.team==Team.GOOD ? 1 : 2 ));
		list[group].push(entity);
	});
	list[2].sort( (a,b) => a.speed-b.speed );
	return [].concat(list[0],list[1],list[2]);
}

function tickItemList(itemList,dt,map,entityList) {
	for( let item of itemList ) {
		if( item.rechargeLeft > 0 ) {
			item.rechargeLeft = Math.max(0,item.rechargeLeft-1);
		}
		if( item.onTick ) {
			item.onTick.call(item,dt,map,entityList);
		}
	}
}


function main(levelName) {

	function render(observer) {
		gui.viewStatus.render(observer,entityList);
		gui.viewSpells.render(observer);
		gui.viewInfo.render(observer);
		gui.viewInventory.render(observer);
		gui.viewRange.render(observer);
		let drawList = createDrawList(observer,map,entityList);
		gui.viewMap.draw(drawList,observer);
		gui.viewMiniMap.render(observer);	// must be after viewMap so the visibility
	}

	function tick(speed) {

		let entityListByTurnOrder = orderByTurn(entityList);
		let dt = 1 / speed;
		for( let entity of entityListByTurnOrder ) {
			DeedManager.tick(entity,dt);
			entity.actionCount += entity.speed / speed;
			while( entity.actionCount >= 1 ) {
				entity.calcVis();
				entity.think();
				entity.act();
				tickItemList(entity.inventory,dt,map,entityList);
				DeedManager.calc(entity);
				entity.actionCount -= 1;
			}
		}
		map.actionCount += 1 / speed;
		while( map.actionCount >= 1 ) {
			tickItemList(map.itemList,dt,map,entityList);
			map.actionCount -= 1;
		}
		DeedManager.cleanup();
		checkDeaths(entityList);
		clearCommands(entityList);
	}

	function messageCanPerceiveEntity(observer,entity) {
		if( !observer ) {
			return true;
		}
		return observer.canPerceiveEntity(entity);
	}

	function messageReceive(message,history) {
		while( history.length > 50 ) {
			history.shift();
		}
		let targetElement = document.getElementById('guiMessageBox');
		targetElement.innerHTML = history.join('\n');
		targetElement.scrollTop = targetElement.scrollHeight
	}

	function onPlayerKey(e) {
		// let keyUp=38, keyDown=40, keyLeft=37, keyRight=39;
		let KeyToCommand = loadKeyMapping("default");

		let player = playerFind(entityList);
		if( !player || player.isDead() ) {
			tick(1.0);
			render(player || spectator);
		}
		else {
			player.command = KeyToCommand[''+e.key] !== undefined ? KeyToCommand[''+e.key] : Command.NONE;

			let timePasses = gui.userCommandHandler.evalCommand(player,e,player.command);
			if( timePasses && player.command !== Command.NONE ) {
				tick(player.speed);
			}
			else {
				// This is required to make commands that do NOT pass time, like donning armor, work.
				player.act(false);
			}
			let area = world.levelChange(map,entityList);
			if( area ) {
				map = area.map;
				entityList = area.entityList;
				player = playerFind(entityList);
			}

			render(player);
			spectator.x = player.x;
			spectator.y = player.y;
		}
	}

	function worldOverlayAdd(group,x,y,sticker) {
		return animationAdd( new AniPaste({ group:group, x:x, y:y, sticker:sticker, duration: true }) );
	}
	function worldOverlayRemove(fn) {
		return animationRemove(fn);
	}

	let dataConditioner = new DataConditioner();
	dataConditioner.validateAndConditionThemeData();
	dataConditioner.integratePlaceData();
	dataConditioner.prepareStaticData();

	let startingLevel = 10;
	window.world = new World(startingLevel);

	let imageRepo = new ImageRepo(PIXI.loader);
	let gui = {};
	gui.viewMap = new ViewMap('guiMap',MaxSightDistance,imageRepo);
	gui.viewMiniMap = new ViewMiniMap('guiMiniMap','guiMiniMapCaption',imageRepo);
	gui.viewSpells = new ViewSpells('guiSpells');
	gui.viewInfo = new ViewInfo('guiInfo')
	gui.viewStatus = new ViewStatus('guiStatus');
	gui.viewRange = new ViewRange(worldOverlayAdd,worldOverlayRemove);
	gui.viewInventory = new ViewInventory('guiInventory',imageRepo);
	gui.userCommandHandler = new UserCommandHandler(gui.viewInventory,gui.viewRange,gui.viewSpells);
	let spectator = {
		x: 0,
		y: 0,
		vis: [],
		canPerceiveEntity: () => true,
		calcVis: () => calcVis(map,spectator.x,spectator.y,MaxSightDistance,false,false,spectator.vis)
	};

	let area = world.createArea(null,0,ThemeList[startingLevel<=1 ? 'gameStart' : 'cavern'],startingLevel>1 ? 'stairsUp' : false);
	world.gateTo(area.id);
	let map = area.map;
	let entityList = area.entityList;
	let player = playerFind(entityList);
	if( !player ) {
		let gate = area.getUnusedGateByTypeId('stairsUp');
		if( !gate ) {
			let pos = map.pickPosEmpty();
			gate = map.itemCreateByTypeId(pos[0],pos[1],'stairsUp');
		}
		let x = gate.x;
		let y = gate.y;
		player = new Entity( map, entityList, MonsterTypeList.player, { x:x, y:y }, null, startingLevel );
		entityList.unshift( player );
	}
	MessageManager.addRecipient(player,messageCanPerceiveEntity,messageReceive);

	let handle = setInterval(function() {
		if( !imageRepo.ready ) {
			return;
		}
		clearInterval(handle);

		$(document).keydown( onPlayerKey );

		render(player);
		tell([player,null,"Welcome to flogue! Use the arrow keys to move, and '.' to wait."]);
		tell(mSubject,player,' ',mVerb,'step',' through the doorway...');
		// The tick is called each time the player takes an action.
	}, 20);
}


</script>
</head>
<body>
	<table>
		<tr><td colspan="2">
			<div id="guiMessageBox"></div>
		</td></tr>
		<tr>
			<td>
				<div id="mapContainer">
					<div id="guiMap"></div>
					<div id="guiInventory"></div>
				</div>
			</td><td>
				<div id="guiStatus">
					<div id='health0' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health1' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health2' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health3' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health4' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health5' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health6' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health7' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health8' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
					<div id='health9' class="health-bar" data-total="1000" data-value="1000">
						<div class="bar">
							<div class="hit"></div>
						</div>
					</div>
				</div>
				<div id="guiSpells">
				</div>
				<div id="guiInfo">
				</div>
				<div id="guiMiniMap">
				</div>
				<div id="guiMiniMapCaption">
				</div>
			</td>
		</tr>
	</table>
	<script>
		main("test");
	</script>
</body>
</html>
